<!DOCTYPE html>
<html>
<head>
<title>NX (PKG4) Format Specification</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<style type="text/css">
body {
    font-family:sans-serif;
    margin: 0 auto;
    width: 85%;
}
table { 
    border-collapse: collapse;
    width: 100%;
}
table, td, th {
    border: 1px solid black;
}
td, th {
    padding: 4px 5px;
}
th {
    background-color: black;
    color: white;
    font-weight: bold;
}
th.name {
    width:12.2%;
    min-width:11em;
}
th.type {
    width:8.5%;
    min-width:6.7em;
}
.mono {
    font-family: monospace;
}
</style>
</head>
<body>
<h1>3rd NX File Format [PKG4]</h1>
<p>The NX file format was designed with speediness and ease of reading in mind, to speed up loading times for anything that uses a node-tree-based data file format.</p>

<p>In the NX file format, the following should be followed:</p>

<ul>
<li>Signed integers use Two's complement.</li>
<li>All multi-byte integer and and floating point types are in little endian byte order.</li>
<li>Floating point types follow IEEE standards.</li>
<li>Any compression should be done using LZ4.</li>
<li>The file extension should be <strong>.nx</strong>.</li>
</ul>

<p>These are the reference implementations of the NX format:</p>

<ul>
<li><a href="https://github.com/NoLifeDev/NoLifeNx">NoLifeNx</a> (C++), by retep998, a library for reading NX files.</li>
<li><a href="https://github.com/NoLifeDev/NoLifeWzToNx">NoLifeWzToNx</a> (C++), by retep998, a tool to convert WZ files to NX.</li>
<li><a href="https://github.com/angelsl/ms-reNX">reNX</a> (C#), by angelsl, a library for reading and writing NX files.</li>
<li><a href="https://github.com/angelsl/ms-wz2nx">WZ2NX</a> (C#), by angelsl, a tool to convert WZ files to NX.</li>
</ul>

<p>In the following specification, <em>Bitmap</em> is synonymous with <em>Canvas data</em>.</p>
<h3>Recommended File Format</h3>
<table>
<tr><th class="name">Name</th><th class="type">Type</th><th class="desc">Description</th></tr>
<tr><td>Header</td><td class="mono">Header</td><td>File header</td></tr>
<tr><td>Node data</td><td class="mono">Node[]</td><td>Node data, including all children.</td></tr>
<tr><td>String offset table</td><td class="mono">UInt64[]</td><td>String offset table. Contiguous block.</td></tr>
<tr><td>String data</td><td class="mono">String[]</td><td>String data.</td></tr>
<tr><td>Bitmap offset table</td><td class="mono">UInt64[]</td><td>Bitmap offset table. Contiguous block.</td></tr>
<tr><td>Bitmaps</td><td class="mono">Canvas[]</td><td>Canvas data.</td></tr>
<tr><td>MP3 offset table</td><td class="mono">UInt64[]</td><td>MP3 offset table. Contiguous block.</td></tr>
<tr><td>MP3 data</td><td class="mono">MP3[]</td><td>MP3 data.</td></tr>
</table>

<h3>Header (52 bytes)</h3>
<table>
<tr><th class="name">Name</th><th class="type">Type</th><th class="desc">Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Magic</td><td class="mono">UInt8[4]</td><td class="mono">"PKG4" = {0x50, 0x4B, 0x47, 0x34}</td></tr>
<tr><td>Node count</td><td class="mono">UInt32</td><td>Total number of nodes in the file. Cannot be zero.</td></tr>
<tr><td>Node block offset</td><td class="mono">Node*</td><td>Unsigned 64-bit offset to the start of the node block, which should be the base node: the parent of all other nodes in the file. This must be a multiple of 4.</td></tr>
<tr><td>String count</td><td class="mono">UInt32</td><td>Total number of string entries in the file. Cannot be zero.</td></tr>
<tr><td>String offset table offset</td><td class="mono">String*</td><td>Unsigned 64-bit offset to the string offset table in the file, with the number of entries equal to the string count. This must be a multiple of 8.</td></tr>
<tr><td>Bitmap count</td><td class="mono">UInt32</td><td>Total number of bitmaps in the file. Zero indicates no canvas data.</td></tr>
<tr><td>Bitmap offset table offset</td><td class="mono">OffsetTable*</td><td>Unsigned 64-bit offset to the bitmap offset table in the file, with the number of entries equal to the bitmap count. This must be a multiple of 8. If count is zero, this is present but ignored.</td></tr>
<tr><td>MP3 count</td><td class="mono">UInt32</td><td>Total number of MP3s in the file. Zero indicates no MP3 data.</td></tr>
<tr><td>MP3 offset table offset</td><td class="mono">OffsetTable*</td><td>Unsigned 64-bit offset to the MP3 offset table in the file, with the number of entries equal to the MP3 count. This must be a multiple of 8. If count is zero, this is present but ignored.</td></tr>
</table>

<h3>Node (20 bytes)</h3>
<p>Each node is assigned a zero-based 32-bit unsigned ID in the order nodes appear in the node block; that is, the first node (the base node) has ID 0, the second node has ID 1, and so on. This ID is used to point to child nodes in nodes.<br />
<br />
All nodes should be in one contiguous block, which should be of size <code>20 * Number of nodes</code>. Children nodes of each parent node must be consecutive in one contiguous block, and the ID of the first child in the block is specified in the <em>First Child ID</em> field of the parent node.

Children nodes of each parent node must be sorted in ascending order according to the UTF-8 value of the node name of each child.

The base node should have an ID of 0, and <em>preferably</em> have type 0 (None).</p>
<table>
<tr><th class="name">Name</th><th class="type">Type</th><th colspan="3" class="desc">Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Node name</td><td class="mono">UInt32</td><td colspan="3">String ID representing the name of this node</td></tr>
<tr><td>First Child ID</td><td class="mono">UInt32</td><td colspan="3">Node ID of first child. Present but ignored if child count is zero (0).</td></tr>
<tr><td>Children count</td><td class="mono">UInt16</td><td colspan="3">Zero means there are no children.</td></tr>
<tr><td>Type</td><td class="mono">UInt16</td><td class="mono" colspan="3">0 = No data<br />1 = Int64<br />2 = Double<br />3 = String (UInt32 ID)<br />4 = Vector<br />5 = Canvas (UInt32 ID, UInt16 Width, UInt16 Height)<br />6 = MP3 (UInt32 ID, UInt32 Length)</td></tr>
<tr><td rowspan="9">Data</td><td rowspan="9">Varies</td><td colspan="3">This field is always 8 bytes. If the data type is less than 8 bytes, only the first few bytes are used and the remaining are ignored.

<tr><th colspan="2">Type</th><th>Description</th></tr>
<tr><td class="mono">0</td><td class="mono">None</td><td>This field is present but ignored.</td></tr>
<tr><td class="mono">1</td><td class="mono">Int64</td><td>64-bit signed integer.</td></tr>
<tr><td class="mono">2</td><td class="mono">Double</td><td>64-bit IEEE double-precision floating point.</td></tr>
<tr><td class="mono">3</td><td class="mono">String</td><td>32-bit unsigned string ID. Remaining 4 bytes ignored.</td></tr>
<tr><td class="mono">4</td><td class="mono">Vector</td><td>Two 32-bit signed integers, for X and Y respectively.</td></tr>
<tr><td class="mono">5</td><td class="mono">Canvas</td><td>32-bit unsigned canvas ID, followed by 16-bit unsigned width and height in that order. Present but ignored if bitmaps are not included in this file.</td></tr>
<tr><td class="mono">6</td><td class="mono">MP3</td><td>32-bit unsigned MP3 ID, followed by 32-bit unsigned data length. Present but ignored if MP3s are not included in this file.</td></tr>
</td></tr>
</table>

<h3>String (2-65537 bytes)</h3>
<p>Each string is assigned a zero-based unsigned 32-bit ID. Offsets to strings are located in the String offset table. Strings do not need to be in a contiguous block, though this is recommended.</p>
<table>
<tr><th class="name">Name</th><th class="type">Type</th><th class="desc">Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Length</td><td class="mono">UInt16</td><td>Length in bytes of the following string</td></tr>
<tr><td>String data</td><td class="mono">UInt8[]</td><td>String data, encoded in UTF-8. This byte array is <code>Length</code> bytes long.</td></tr>
</table>

<h3>Bitmap (4-4294967299 bytes)</h3>
<p>Each bitmap is assigned a zero-based unsigned 32-bit ID. Offsets to bitmaps are located in the Bitmap offset table. Bitmaps do not need to be in a contiguous block, though this is recommended.</p>
<table>
<tr><th class="name">Name</th><th class="type">Type</th><th class="desc">Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Length</td><td class="mono">UInt32</td><td>Length, in bytes, of the image data. Uncompressed length is <code>width * height * 4</code>. Width and height are specified in the NX node's data field after the Canvas ID.</td></tr>
<tr><td>Data</td><td class="mono">UInt8[]</td><td>Image data, stored in BGRA8888 format, that is, 1 byte each for the blue, green, red and alpha components, in that order. This data is compressed with LZ4. This byte array is <code>Length</code> bytes long.</td></tr>
</table>

<h3>MP3 (0-4294967295 bytes)</h3>
<p>Each MP3 is assigned a zero-based unsigned 32-bit ID. Offsets to MP3s are located in the MP3 offset table. MP3s do not need to be a contiguous block, though this is recommended.</p>
<table>
<tr><th class="name">Name</th><th class="type">Type</th><th class="desc">Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>MP3 data</td><td class="mono">UInt8[]</td><td>MP3 data. This byte array is <code>Length</code> bytes long. Length is specified in the NX node's data field after the MP3 ID.</td></tr>
</table>

<h3>Offset Table</h3>
<p>Offset arrays are used to refer to Strings, Bitmaps and MP3s. String offsets must be a multiple of 2. Bitmap and MP3 offsets must be a multiple of 8.</p>
<table>
<tr><th class="name">Name</th><th class="type">Type</th><th class="desc">Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Offset Array</td><td class="mono">UInt64[]</td><td>Sequential offset array; the first offset has ID 0, the second has ID 1, and so on.</td></tr>
</table>

<p><strong>Acknowledgements:</strong></p>
<ul>
<li><strong><a href="https://github.com/retep998">Retep998</a></strong>, one of the two co-writers of the NX format.</li>
<li><strong><a href="https://github.com/angelsl">angelsl</a></strong>, the other co-writer and the author of this Specification.</li>
<li><strong><a href="https://github.com/aaronweiss74">aaronweiss74</a></strong>, for his suggestions, help and support, and for writing <a href="https://github.com/aaronweiss74/pkgnx">pkgnx</a>.</li>
<li><strong><a href="https://github.com/Zepheus">Cedric</a></strong>, for his suggestions, help and support, and for writing <a href="https://github.com/Zepheus/javanx">javanx</a>.</li>
<li><strong><a href="https://github.com/strax">Sami</a></strong>, for his support and for writing <a href="https://github.com/strax/nx-pkg4">nx-pkg4</a>.</li>
<li><strong><a href="http://code.google.com/p/lz4/">LZ4</a></strong>, the compression algorithm used in NX.</li>
<li><strong><a href="http://github.com/">GitHub</a></strong>, for hosting this and all our projects.</li>
</ul>

<p>Contributions to this specification are welcome. Please fork and then send a pull request to <a href="https://github.com/nxformat/nxformat.github.com">this repository</a>.<br />
<br />
<a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/80x15.png" /></a><br />This <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">specification</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.
</body>
</html>