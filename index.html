<!DOCTYPE html>
<html>
<head>
<title>NX (PKG3) Format Specification</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<style type="text/css">
body {
    font-family:sans-serif;
}
table { 
    border-collapse: collapse;
}
table, td, th {
    border: 1px solid black;
}
td, th {
    padding: 4px 5px;
}
th {
    background-color: black;
    color: white;
    font-weight: bold;
}
.mono {
    font-family: monospace;
}
</style>
</head>
<body>
<h1>2nd NX File Format [PKG3]</h1>
<p>The NX file format was designed with speediness and ease of reading in mind, to speed up loading times for anything that uses a node-tree-based data file format.</p>

<p>In the NX file format, the following should be followed:</p>

<ul>
<li>Signed integers use Two's complement.</li>
<li>All multi-byte integer and and floating point types are in little endian byte order.</li>
<li>Floating point types follow IEEE standards.</li>
<li>Any compression should be done using LZ4.</li>
<li>The file extension should be <strong>.nx</strong>.</li>
</ul>

<p>These are the reference implementations of the NX format:</p>

<ul>
<li><a href="https://github.com/NoLifeDev/NoLifeNx">NoLifeNx</a> (C++), by retep998, a library for reading NX files.</li>
<li><a href="https://github.com/NoLifeDev/NoLifeWzToNx">NoLifeWzToNx (C++), by retep998, a tool to convert WZ files to NX.</li>
<li><a href="https://github.com/angelsl/ms-reNX">reNX</a> (C#), by angelsl, a library for reading and writing NX files.</li>
<li><a href="https://github.com/angelsl/ms-wz2nx">WZ2NX</a> (C#), by angelsl, a tool to convert WZ files to NX.</li>
</ul>

<p>In the following specification, <em>Bitmap</em> is synonymous with <em>Canvas data</em>.</p>
<h3>Recommended File Format</h3>
<table>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
<tr><td>Header</td><td class="mono">Header</td><td>File header</td></tr>
<tr><td>Node data</td><td class="mono">Node[]</td><td>Node data, including all children.</td></tr>
<tr><td>String data</td><td class="mono">String[]</td><td>String data. Contiguous block.</td></tr>
<tr><td>Bitmap offset table</td><td class="mono">UInt64[]</td><td>Bitmap offset table. Contiguous block.</td></tr>
<tr><td>Bitmaps</td><td class="mono">Canvas[]</td><td>Canvas data.</td></tr>
<tr><td>MP3 offset table</td><td class="mono">UInt64[]</td><td>MP3 offset table. Contiguous block.</td></tr>
<tr><td>MP3 data</td><td class="mono">MP3[]</td><td>MP3 data.</td></tr>
</table>

<h3>Header (52 bytes)</h3>
<table>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Magic</td><td class="mono">UInt8[4]</td><td class="mono">"PKG3" = {0x50, 0x4B, 0x47, 0x33}</td></tr>
<tr><td>Node count</td><td class="mono">UInt32</td><td>Total number of nodes in the file. Cannot be zero.</td></tr>
<tr><td>Node block offset</td><td class="mono">Node*</td><td>Unsigned 64-bit offset to the start of the node block, which should be the base node: the parent of all other nodes in the file.</td></tr>
<tr><td>String count</td><td class="mono">UInt32</td><td>Total number of string entries in the file. Cannot be zero.</td></tr>
<tr><td>String block offset</td><td class="mono">String*</td><td>Unsigned 64-bit offset to the first string in the file, the start of the string block.</td></tr>
<tr><td>Bitmap count</td><td class="mono">UInt32</td><td>Total number of bitmaps in the file. Zero indicates no canvas data.</td></tr>
<tr><td>Bitmap offset table offset</td><td class="mono">OffsetTable*</td><td>Unsigned 64-bit offset to the bitmap offset table in the file, with the number of entries equal to the bitmap count. If count is zero, this is present but ignored.</td></tr>
<tr><td>MP3 count</td><td class="mono">UInt32</td><td>Total number of MP3s in the file. Zero indicates no MP3 data.</td></tr>
<tr><td>MP3 offset table offset</td><td class="mono">OffsetTable*</td><td>Unsigned 64-bit offset to the MP3 offset table in the file, with the number of entries equal to the MP3 count.  If count is zero, this is present but ignored.</td></tr>
</table>

<h3>Node (20 bytes)</h3>
<p>Each node is assigned a zero-based 32-bit unsigned ID in the order nodes appear in the node block; that is, the first node (the base node) has ID 0, the second node has ID 1, and so on. This ID is used to point to child nodes in nodes.<br />
<br />
All nodes should be in one contiguous block, which should be of size <span class="mono">20 * Number of nodes</span>. Children nodes of each parent node must be consecutive in one contiguous block, and the ID of the first child in the block is specified in the <em>First Child ID</em> field of the parent node.

The base node should have an ID of 0, and <em>preferably</em> have type 0 (None).</p>
<table>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Node name</td><td class="mono">UInt32</td><td>String ID representing the name of this node</td></tr>
<tr><td>Children count</td><td class="mono">UInt16</td><td>Zero means there are no children.</td></tr>
<tr><td>Type</td><td class="mono">UInt16</td><td class="mono">0 = No data<br />1 = Int32<br />2 = Double<br />3 = String (UInt32 ID)<br />4 = Vector<br />5 = Canvas (UInt32 ID)<br />6 = MP3 (UInt32 ID)</td></tr>
<tr><td>Data</td><td>Varies</td><td>This field is always 8 bytes. If the data type is less than 8 bytes, only the first few bytes are used and the remaining are ignored.
<table>
<tr><th colspan="2">Type</th><th>Description</th></tr>
<tr><td class="mono">0</td><td class="mono">None</td><td>This field is present but ignored.</td></tr>
<tr><td class="mono">1</td><td class="mono">Int32</td><td>32-bit signed integer. Remaining 4 bytes ignored.</td></tr>
<tr><td class="mono">2</td><td class="mono">Double</td><td>64-bit IEEE double-precision floating point.</td></tr>
<tr><td class="mono">3</td><td class="mono">String</td><td>32-bit unsigned string ID. Remaining 4 bytes ignored.</td></tr>
<tr><td class="mono">4</td><td class="mono">Vector</td><td>Two 32-bit signed integers, for X and Y respectively.</td></tr>
<tr><td class="mono">5</td><td class="mono">Canvas</td><td>32-bit unsigned canvas ID. Remaining 4 bytes ignored. Present but ignored if bitmaps are not included in this file.</td></tr>
<tr><td class="mono">6</td><td class="mono">MP3</td><td>32-bit unsigned MP3 ID. Remaining 4 bytes ignored. Present but ignored if MP3s are not included in this file.</td></tr>
</table></td></tr>
<tr><td>First Child ID</td><td class="mono">UInt32</td><td>Node ID of first child. Present but ignored if child count is zero (0).</td></tr>
</table>

<h3>String (2-65537 bytes)</h3>
<p>Each string is assigned a zero-based unsigned 32-bit ID in the order they appear in the string block; that is, the first string has ID 0, the second string has ID 1, and so on. This ID is used to refer to strings throughout the file.</p>
<table>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Length</td><td class="mono">UInt16</td><td>Length in bytes of the following string</td></tr>
<tr><td>String data</td><td class="mono">UInt8[]</td><td>String data, encoded in UTF-8. This byte array is <span class="mono">Length</span> bytes long.</td></tr>
</table>

<h3>Bitmap (8-4294967303 bytes)</h3>
<p>Each bitmap is assigned a zero-based unsigned 32-bit ID. Offsets to bitmaps are located in the Bitmap offset table. Bitmaps do not need to be in a contiguous block, though this is recommended.</p>
<table>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Width</td><td class="mono">UInt16</td><td>Width, in pixels, of the image</td></tr>
<tr><td>Height</td><td class="mono">UInt16</td><td>Height, in pixels, of the image</td></tr>
<tr><td>Length</td><td class="mono">UInt32</td><td>Length, in bytes, of the image data. Uncompressed length is <span class="mono">width * height * 4</span></td></tr>
<tr><td>Data</td><td class="mono">UInt8[]</td><td>Image data, stored in BGRA8888 format, that is, 1 byte each for the blue, green, red and alpha components, in that order. This data is compressed with LZ4. This byte array is <span class="mono">Length</span> bytes long.</td></tr>
</table>

<h3>MP3 (4-4294967299 bytes)</h3>
<p>Each MP3 is assigned a zero-based unsigned 32-bit ID. Offsets to MP3s are located in the MP3 offset table. MP3s do not need to be a contiguous block, though this is recommended.</p>
<table>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Length</td><td class="mono">UInt32</td><td>Length, in bytes, of the MP3 data.</td></tr>
<tr><td>MP3 data</td><td class="mono">UInt8[]</td><td>MP3 data. This byte array is <span class="mono">Length</span> bytes long.</td></tr>
</table>

<h3>Offset Table</h3>
<p>Offset arrays are used to refer to Bitmaps and MP3s.</p>
<table>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Offset Array</td><td class="mono">UInt64[]</td><td>Sequential offset array; the first offset has ID 0, the second has ID 1, and so on.</td></tr>
</table>

<p><strong>Acknowledgements:</strong></p>
<ul>
<li><strong><a href="https://github.com/retep998">Retep998</a></strong>, one of the two co-writers of the NX format.</li>
<li><strong><a href="https://github.com/angelsl">angelsl</a></strong>, the other co-writer and the author of this Specification.</li>
<li><strong><a href="https://github.com/aaronweiss74">aaronweiss74</a></strong>, for his support and for writing <a href="https://github.com/aaronweiss74/libjinx2">libjinx2</a>.</li>
<li><strong>Cedric</strong>, for his suggestions, help and support.</li>
<li><strong><a href="http://code.google.com/p/lz4/">LZ4</a></strong>, the compression algorithm used in NX.</li>
<li><strong><a href="http://github.com/">GitHub</a>, for hosting this and all our projects.</li>
</ul>

Contributions to this specification are welcome. Please fork and then send a pull request to <a href="https://github.com/nxformat/nxformat.github.com">this repository</a>.
</body>
</html>