<!DOCTYPE html>
<html>
<head>
<title>NX (PKG5) Format Specification</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<style type="text/css">
@import url(https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400italic,700|Inconsolata);
body {
    font-family: 'Source Sans Pro', sans-serif;
    margin: 0 auto;
    max-width: 800px;
}
table { 
    border-collapse: collapse;
    width: 100%;
}
table, td, th {
    border: 1px solid black;
}
td, th {
    padding: 4px 5px;
}
th {
    background-color: black;
    color: white;
    font-weight: bold;
}
th.name {
    width:12.2%;
    min-width:11em;
}
th.type {
    width:8.5%;
    min-width:6.7em;
}
.mono, code {
    font-family: 'Inconsolata', 'Consolas', monospace;
}
</style>
</head>
<body>
<h1>4th NX File Format [PKG5]</h1>
<p>The NX file format was designed with speediness and ease of reading in mind, to speed up loading times for anything that uses a node-tree-based data file format.</p>

<p>In the NX file format, the following should be followed:</p>

<ul>
<li>All offsets are unsigned 64-bit integers, zero-based, and are from the beginning of the file.</li>
<li>Signed integers use Two's complement.</li>
<li>All multi-byte integer and and floating point types are in little endian byte order.</li>
<li>Floating point types follow IEEE standards.</li>
<li>Any compression should be done using LZ4.</li>
<li>The file extension should be <strong>.nx</strong>.</li>
</ul>

<p>These are the reference implementations of the NX format:</p>

<ul>
<li><a href="https://github.com/NoLifeDev/NoLifeNx">NoLifeNx</a> (C++), by retep998, a library for reading NX files.</li>
<li><a href="https://github.com/NoLifeDev/NoLifeWzToNx">NoLifeWzToNx</a> (C++), by retep998, a tool to convert WZ files to NX.</li>
<li><a href="https://github.com/angelsl/ms-reNX">reNX</a> (C#), by angelsl, a library for reading and writing NX files.</li>
<li><a href="https://github.com/angelsl/ms-wz2nx">WZ2NX</a> (C#), by angelsl, a tool to convert WZ files to NX.</li>
</ul>

<h3>Recommended File Format</h3>
<table>
<tr><th class="name">Name</th><th class="type">Type</th><th class="desc">Description</th></tr>
<tr><td>Header</td><td class="mono">Header</td><td>File header</td></tr>
<tr><td>Node data</td><td class="mono">Node[]</td><td>Node data, including all children.</td></tr>
<tr><td>String offset table</td><td class="mono">UInt64[]</td><td>String offset table. Contiguous block.</td></tr>
<tr><td>String data</td><td class="mono">String[]</td><td>String data.</td></tr>
<tr><td>Compressed Byte Array offset table</td><td class="mono">UInt64[]</td><td>Compressed Byte Array offset table. Contiguous block.</td></tr>
<tr><td>Compressed Byte Arrays</td><td class="mono">Compressed Byte Array[]</td><td>Compressed byte array data.</td></tr>
<tr><td>Uncompressed Byte Array offset table</td><td class="mono">UInt64[]</td><td>Uncompressed Byte Array offset table. Contiguous block.</td></tr>
<tr><td>Uncompressed Byte Array data</td><td class="mono">Uncompressed Byte Array[]</td><td>Uncompressed byte array data.</td></tr>
</table>

<h3>Header (60 bytes)</h3>
<table>
<tr><th class="name">Name</th><th class="type">Type</th><th class="desc">Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Magic</td><td class="mono">UInt8[4]</td><td class="mono">"PKG5" = {0x50, 0x4B, 0x47, 0x35}</td></tr>
<tr><td>Node count</td><td class="mono">UInt32</td><td>Total number of nodes in the file. Cannot be zero.</td></tr>
<tr><td>Node block offset</td><td class="mono">Node*</td><td>Offset to the start of the node block, which should be the base node: the parent of all other nodes in the file. This must be a multiple of 4.</td></tr>
<tr><td>String count</td><td class="mono">UInt32</td><td>Total number of <code>String</code> entries in the file. Cannot be zero.</td></tr>
<tr><td>String offset table offset</td><td class="mono">OffsetTable*</td><td>Offset to the string offset table in the file, with the number of entries equal to the <code>String</code> count. This must be a multiple of 8.</td></tr>
<tr><td>Compressed Byte Array count</td><td class="mono">UInt32</td><td>Total number of <code>Compressed Byte Array</code> entries in the file.</td></tr>
<tr><td>Compressed Byte Array offset table offset</td><td class="mono">OffsetTable*</td><td>Offset to the compressed byte array offset table, with the number of entries equal to the <code>Compressed Byte Array count</code>. This must be a multiple of 8.</td></tr>
<tr><td>Uncompressed Byte Array count</td><td class="mono">UInt32</td><td>Total number of <code>Uncompressed Byte Array</code> entries in the file.</td></tr>
<tr><td>Uncompressed Byte Array offset table offset</td><td class="mono">OffsetTable*</td><td>Offset to the uncompressed byte array offset table in the file, with the number of entries equal to the <code>Uncompressed Byte Array count</code>. This must be a multiple of 8.</td></tr>
<tr><td>Metadata</td><td class="mono">UInt64</td><td>This field is ignored by parsers and can be used to store application-specific metadata.</td></tr>
</table>

<h3>Node (20 bytes)</h3>
<p>Each <code>Node</code> is assigned a zero-based 32-bit unsigned ID in the order they appear in the node block; that is, the first <code>Node</code> (the base node) has ID 0, the second node has ID 1, and so on. This ID is used to point to child nodes of <code>Node</code>s.<br />
<br />
All <code>Node</code>s should be in one contiguous block, which should be of size <code>20 * Number of nodes</code>. <code>Node</code>s must be aligned to an 8-byte boundary.<br />
<br />
Children <code>Node</code>s of each parent <code>Node</code> must be consecutive in one contiguous block, and the ID of the first child in the block is specified in the <code>First Child ID</code> field of the parent <code>Node</code>. Children <code>Node</code>s of each parent <code>Node</code> must be sorted in ascending order according to the UTF-8 value of the node name of each child. Children <code>Node</code>s of any given parent <code>Node</code> must have unique node names.<br />
<br />
The base node should have an ID of 0, and <em>preferably</em> have type 0 (None).</p>
<table>
<tr><th class="name">Name</th><th class="type">Type</th><th colspan="3" class="desc">Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Node name</td><td class="mono">UInt32</td><td colspan="3"><code>String</code> ID representing the name of this node</td></tr>
<tr><td>First Child ID</td><td class="mono">UInt32</td><td colspan="3">Node ID of first child. Present but ignored if child count is zero (0).</td></tr>
<tr><td>Children count</td><td class="mono">UInt16</td><td colspan="3">Zero means there are no children.</td></tr>
<tr><td>Type</td><td class="mono">UInt16</td><td class="mono" colspan="3">0 = No data<br />1 = Int64<br />2 = Double<br />3 = String (UInt32 ID)<br />4 = Vector<br />5 = Compressed Byte Array (UInt32 ID)<br />6 = Uncompressed Byte Array (UInt32 ID)</td></tr>
<tr><td rowspan="9">Data</td><td rowspan="9">Varies</td><td colspan="3">This field is always 8 bytes.

<tr><th colspan="2">Type</th><th>Description</th></tr>
<tr><td class="mono">0</td><td class="mono">None</td><td>This field is ignored.</td></tr>
<tr><td class="mono">1</td><td class="mono">Int64</td><td>64-bit signed integer.</td></tr>
<tr><td class="mono">2</td><td class="mono">Double</td><td>64-bit IEEE double-precision floating point.</td></tr>
<tr><td class="mono">3</td><td class="mono">String</td><td>32-bit unsigned string ID.</td></tr>
<tr><td class="mono">4</td><td class="mono">Vector</td><td>Two 32-bit signed integers (<code>Int32</code>), for X and Y respectively.</td></tr>
<tr><td class="mono">5</td><td class="mono">Compressed byte array</td><td>32-bit unsigned compressed byte array ID. Ignored if <code>Compressed Byte Array count</code> in <code>Header</code> is <code>0</code>.</td></tr>
<tr><td class="mono">6</td><td class="mono">Uncompressed byte array</td><td>32-bit unsigned uncompressed byte array ID. Ignored if <code>Uncompressed Byte Array count</code> in <code>Header</code> is <code>0</code></td></tr>
</td></tr>
</table>

<h3>String (2&ndash;65537 bytes)</h3>
<p>Each <code>String</code> is assigned a zero-based unsigned 32-bit ID. Offsets to <code>String</code>s are located in the String offset table. <code>String</code>s do not need to be in a contiguous block, though this is recommended. <code>String</code>s must be aligned to a 2-byte boundary.</p>
<table>
<tr><th class="name">Name</th><th class="type">Type</th><th class="desc">Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Length</td><td class="mono">UInt16</td><td>Length, in bytes, of the following string data</td></tr>
<tr><td>String data</td><td class="mono">UInt8[]</td><td>String data, encoded in UTF-8. This byte array is <code>Length</code> bytes long.</td></tr>
<tr><td>Null</td><td class="mono">UInt8</td><td class="mono">'\0' = {0x00}</td>
</table>

<h3>Compressed Byte Array (24&ndash;4294967319 bytes)</h3>
<p>Each <code>Compressed Byte Array</code> is assigned a zero-based unsigned 32-bit ID. Offsets to <code>Compressed Byte Array</code>s are located in the uncompressed byte array offset table. Byte arrays do not need to be in a contiguous block, though this is recommended. Byte arrays must be aligned to an 8-byte boundary.</p>
<table>
<tr><th class="name">Name</th><th class="type">Type</th><th class="desc">Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Length</td><td class="mono">UInt64</td><td>Length, in bytes, of the compressed byte array.</td></tr>
<tr><td>Uncompressed length</td><td class="mono">UInt64</td><td>Length, in bytes, of the byte array.</td></tr>
<tr><td>Metadata</td><td class="mono">UInt64</td><td>This field is ignored by parsers and can be used to store application-specific metadata.</td></tr>
<tr><td>Data</td><td class="mono">UInt8[]</td><td>Data, compressed using LZ4. This byte array is <code>Length</code> bytes long.</td></tr>
</table>

<h3>Uncompressed Byte Array (16&ndash;4294967311 bytes)</h3>
<p>Each <code>Uncompressed Byte Array</code> is assigned a zero-based unsigned 32-bit ID. Offsets to <code>Uncompressed Byte Array</code>s are located in the uncompressed byte array offset table. Byte arrays do not need to be in a contiguous block, though this is recommended. Byte arrays must be aligned to an 8-byte boundary.</p>
<table>
<tr><th class="name">Name</th><th class="type">Type</th><th class="desc">Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Length</td><td class="mono">UInt64</td><td>Length, in bytes, of the byte array.</td></tr>
<tr><td>Metadata</td><td class="mono">UInt64</td><td>This field is ignored by parsers and can be used to store application-specific metadata.</td></tr>
<tr><td>Data</td><td class="mono">UInt8[]</td><td>Data. This byte array is <code>Length</code> bytes long.</td></tr>
</table>

<h3>Offset Table</h3>
<p>Offset tables are used to refer to <code>String</code>s and byte arrays. <code>String</code> offsets must be a multiple of 2. Byte array offsets must be a multiple of 8.</p>
<table>
<tr><th class="name">Name</th><th class="type">Type</th><th class="desc">Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Offset Array</td><td class="mono">UInt64[]</td><td>Sequential offset array; the first offset has ID 0, the second has ID 1, and so on.</td></tr>
</table>

<h2>WZ-specific Data Types</h2>
<p>This section recommends how Bitmaps and Audio files from WZs should be stored. This is also how the reference converter, WZ2NX, will store Bitmaps and MP3s.<br />
<br />
In a NX file containing Bitmaps and Audio files from WZs that follows this recommendation, the first 2 bytes of the <code>Metadata</code> field of the <code>Header</code> should have bits <code>15</code>, <code>10</code>, <code>6</code> and <code>0</code> set to <code>1</code>, that is, ORed with <code>0b1000010001000001 = {0x84, 0x41}</code>.</p>
<h3>Bitmap</h3>
<p>The <code>Metadata</code> field of the byte array containing a bitmap should be set to <code>"WZBITMAP" = {0x57, 0x5A, 0x42, 0x49, 0x54, 0x4D, 0x41, 0x50}</code>. Bitmaps can be stored as either <code>Compressed Byte Array</code>s or <code>Uncompressed Byte Array</code>s.<br />
<br />
If bitmap data is omitted in an NX file, the <code>Node</code>s containing a bitmap should point to an empty byte array, or the byte array type should be omitted (count 0 in <code>Header</code>). Otherwise, the structure of the data within the byte array is as follows.</p>
<table>
<tr><th class="name">Name</th><th class="type">Type</th><th class="desc">Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Width</td><td class="mono">UInt32</td><td>Width of the following image.</td></tr>
<tr><td>Height</td><td class="mono">UInt32</td><td>Height of the following image.</td></tr>
<tr><td>Data</td><td class="mono">UInt8[]</td><td>Bitmap data, stored in BGRA8888 format, that is, 1 byte each for blue, green, red and alpha, in that order. This byte array is <code>Width * Height * 4</code> bytes long.</td></tr>
</table>

<h3>Audio</h3>
<p>The <code>Metadata</code> field of the byte array containing audio should be set to <code>"WZAUDION" = {0x57, 0x5A, 0x41, 0x55, 0x44, 0x49, 0x4F, 0x4E}</code>. Audio can be stored as either <code>Compressed Byte Array</code>s or <code>Uncompressed Byte Array</code>s.<br />
<br />
If audio data is omitted in an NX file, the <code>Node</code>s containing audio should point to an empty byte array, or the byte array type should be omitted (count 0 in <code>Header</code>). Otherwise, the structure of the data within the byte array is as follows.</p>
<table>
<tr><th class="name">Name</th><th class="type">Type</th><th class="desc">Description</th></tr>
<!-- <tr><td></td><td class="mono"></td><td></td></tr> -->
<tr><td>Audio data</td><td class="mono">UInt8[]</td><td>Audio data, including the 82-byte WZ audio header. This byte array is <code>Length</code> bytes long. Length is specified in the <code>Byte Array</code> structure.</td></tr>
</table>

<p><strong>Acknowledgements:</strong></p>
<ul>
<li><strong><a href="https://github.com/retep998">Retep998</a></strong>, one of the two co-writers of the NX format.</li>
<li><strong><a href="https://github.com/angelsl">angelsl</a></strong>, the other co-writer and the author of this Specification.</li>
<li><strong><a href="https://github.com/aaronweiss74">aaronweiss74</a></strong>, for his suggestions, help and support, and for writing <a href="https://github.com/aaronweiss74/pkgnx">pkgnx</a>.</li>
<li><strong><a href="https://github.com/Zepheus">Cedric</a></strong>, for his suggestions, help and support, and for writing <a href="https://github.com/Zepheus/javanx">javanx</a>.</li>
<li><strong><a href="https://github.com/strax">Sami</a></strong>, for his support and for writing <a href="https://github.com/strax/nx-pkg4">nx-pkg4</a>.</li>
<li><strong><a href="http://code.google.com/p/lz4/">LZ4</a></strong>, the compression algorithm used in NX.</li>
<li><strong><a href="http://github.com/">GitHub</a></strong>, for hosting this and all our projects.</li>
</ul>

<p>Contributions to this specification are welcome. Please fork and then send a pull request to <a href="https://github.com/nxformat/nxformat.github.com">this repository</a>.<br />
<br />
<a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/80x15.png" /></a><br />This <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">specification</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.
</body>
</html>